import numpy as np
import time

from ._simfolder_utils import *
from ._demo import get_default_mliter_folder
from typing import TYPE_CHECKING
if TYPE_CHECKING: # pragma: no cover
    from . import MLTraining


def bench_iter(self:'MLTraining', simfolder=None, ml_iter_savefolder=None, max_iter=1000, Vext_integration_n=7) -> float:
    """
    Benchmarks the iterative training process by comparing the density profiles 
    generated by the model with the reference profiles.
    Args:
        simfolder (str, optional): Path to the folder containing simulation data. 
            Defaults to `self.datafolder`.
        ml_iter_savefolder (str, optional): Path to the folder where iterated 
            profiles are saved. If not provided, it is determined using 
            `get_default_mliter_folder`.
        max_iter (int, optional): Maximum number of iterations for ensuring 
            model existence. Defaults to 1000.
        Vext_integration_n (int, optional): Number of integration points for 
            external potential. Defaults to 7.
    Returns:
        tuple: A tuple containing three numpy arrays:
            - losses (np.ndarray): Mean squared error between the reference 
              and model-generated density profiles for each file.
            - metrics (np.ndarray): Mean absolute error between the reference 
              and model-generated density profiles for each file.
            - mean_rhos (np.ndarray): Mean values of the reference density 
              profiles for each file.
    """
    if simfolder is None:
        simfolder = self.datafolder
    if ml_iter_savefolder is None:
        ml_iter_savefolder = get_default_mliter_folder(self, simfolder)
    
    print("Ensuring that there are iterated profiles in folder ", ml_iter_savefolder)
    self.ensure_model_iter_existance(potfolder=simfolder, ml_iter_savefolder=ml_iter_savefolder, max_iter=max_iter, Vext_integration_n=Vext_integration_n)
    print("Done!")
    
    losses = []
    metrics = []
    mean_rhos = []
    
    for i in range(1, 1+max_file_num(simfolder)):
        rho = get_rho(simfolder, i)
        rho_ml = get_rho(ml_iter_savefolder, i)
        
        losses.append(np.mean((rho[rho>0] - rho_ml[rho>0])**2))
        metrics.append(np.mean(np.abs(rho[rho>0] - rho_ml[rho>0])))
        mean_rhos.append(np.mean(rho[rho>0]))
    
    return np.array(losses), np.array(metrics), np.array(mean_rhos)

def bench_iter_time(self:'MLTraining', potfolder=None, iters=1000, repetitions=20, return_std=False) -> float:
    if potfolder is None:
        potfolder = self.datafolder
    Vext = get_Vext(potfolder, 1)
    
    times = []
    for i in range(repetitions):
        start = time.time()
        self.minimize(Vext, max_iter=iters, tol=0)
        times.append(time.time() - start)
        
    
    if return_std:
        return np.mean(times), np.std(times, ddof=1)
    return np.mean(times)




def calc_loss(self, rhos=None, c1s=None):
    if rhos is None or c1s is None:
        rho_profiles = []
        c1_profiles = []
        for i in range(1, max_file_num(self.datafolder)+1):
            rho_profiles.append(get_rho(self.datafolder, i))
            c1_profiles.append(get_c1(self.datafolder, i, rho_profiles[-1]))
    return self.calc_criterion(rhos, c1s, self.criterion, self.device).mean()
        
def bench_c1(self, rhos=None, c1s=None):
    if rhos is None or c1s is None:
        rhos = []
        c1s = []
        for i in range(1, max_file_num(self.datafolder)+1):
            rhos.append(get_rho(self.datafolder, i))
            c1s.append(get_c1(self.datafolder, i, rhos[-1]))
    return self.calc_criterion(rhos, c1s, self.criterion, self.device), self.calc_criterion(rhos, c1s, self.metric, self.device)